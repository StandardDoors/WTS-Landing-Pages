---
id: python_error_handling
description: "Python error handling, exception management, and robust error recovery patterns"
---

# Python Error Handling

Python error handling, exception management, and robust error recovery patterns.

## Exception Handling Best Practices

### Use Specific Exception Types
- **Use specific exception types**, not bare `except:`
- **Catch the most specific exception first**
- **Include meaningful error messages**
- **Log errors appropriately** with context

```python
# ✅ Good exception handling
try:
    result = api_call()
except requests.exceptions.RequestException as e:
    logger.error(f"API call failed: {e}")
    return None
except ValueError as e:
    logger.warning(f"Invalid data received: {e}")
    return default_value
except Exception as e:
    logger.exception(f"Unexpected error: {e}")
    raise

# ❌ Poor exception handling
try:
    result = api_call()
except:
    pass
```

### Exception Hierarchy
```python
# Handle exceptions from most specific to most general
try:
    process_data()
except FileNotFoundError:
    # Handle missing file specifically
    logger.error("Configuration file not found")
    create_default_config()
except PermissionError:
    # Handle permission issues
    logger.error("Permission denied accessing file")
    raise
except IOError:
    # Handle other I/O errors
    logger.error("I/O error occurred")
    raise
except Exception:
    # Handle any other unexpected errors
    logger.exception("Unexpected error during processing")
    raise
```

## Custom Exceptions

### Create Domain-Specific Exceptions
```python
class APIError(Exception):
    """Base exception for API-related errors."""
    pass

class AuthenticationError(APIError):
    """Raised when authentication fails."""
    pass

class ValidationError(Exception):
    """Raised when data validation fails."""
    
    def __init__(self, message, field=None, value=None):
        self.field = field
        self.value = value
        super().__init__(message)

class ConfigurationError(Exception):
    """Raised when configuration is invalid."""
    
    def __init__(self, message, config_key=None):
        self.config_key = config_key
        super().__init__(message)
```

### Using Custom Exceptions
```python
def validate_user_input(data):
    """Validate user input data."""
    if not data.get('email'):
        raise ValidationError("Email is required", field='email')
    
    if not data.get('age') or data['age'] < 0:
        raise ValidationError(
            "Age must be a positive number", 
            field='age', 
            value=data.get('age')
        )

def authenticate_user(token):
    """Authenticate user with token."""
    if not token:
        raise AuthenticationError("Token is required")
    
    if not is_valid_token(token):
        raise AuthenticationError("Invalid token provided")
```

## API Error Handling Patterns

### Retry Logic with Exponential Backoff
```python
import time
import random
from functools import wraps

def retry_with_backoff(max_retries=3, base_delay=1, max_delay=60):
    """Decorator for retrying functions with exponential backoff."""
    
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except (requests.exceptions.ConnectionError, 
                       requests.exceptions.Timeout) as e:
                    if attempt == max_retries - 1:
                        raise
                    
                    # Calculate delay with jitter
                    delay = min(base_delay * (2 ** attempt), max_delay)
                    jitter = random.uniform(0.1, 0.3) * delay
                    time.sleep(delay + jitter)
                    
                    logger.warning(f"Attempt {attempt + 1} failed, retrying in {delay:.1f}s")
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

@retry_with_backoff(max_retries=3)
def make_api_call(url, data):
    """Make API call with automatic retry."""
    response = requests.post(url, json=data, timeout=30)
    response.raise_for_status()
    return response.json()
```

### Notion API Error Handling (Specific Example)
```python
import time
from notion_client import APIResponseError

def safe_notion_query(notion_client, **query_params):
    """Make Notion API call with proper error handling."""
    max_retries = 3
    base_delay = 1
    
    for attempt in range(max_retries):
        try:
            return notion_client.databases.query(**query_params)
            
        except APIResponseError as e:
            if e.status == 429:  # Rate limited
                delay = base_delay * (2 ** attempt)
                logger.warning(f"Rate limited, waiting {delay}s before retry")
                time.sleep(delay)
                continue
                
            elif e.status == 401:
                raise AuthenticationError("Invalid Notion API token")
                
            elif e.status == 404:
                raise APIError(f"Notion resource not found: {e}")
                
            else:
                logger.error(f"Notion API error: {e.status} - {e}")
                raise APIError(f"Notion API error: {e}")
                
        except requests.exceptions.RequestException as e:
            if attempt == max_retries - 1:
                raise APIError(f"Network error calling Notion API: {e}")
            
            delay = base_delay * (2 ** attempt)
            time.sleep(delay)
    
    raise APIError(f"Failed after {max_retries} attempts")
```

## Error Logging Best Practices

### Structured Logging
```python
import logging
import traceback

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def process_user_data(user_id):
    """Process user data with proper error logging."""
    try:
        user = fetch_user(user_id)
        result = complex_processing(user)
        return result
        
    except ValidationError as e:
        logger.warning(
            f"Validation failed for user {user_id}: {e}",
            extra={'user_id': user_id, 'field': e.field}
        )
        raise
        
    except APIError as e:
        logger.error(
            f"API error processing user {user_id}: {e}",
            extra={'user_id': user_id}
        )
        raise
        
    except Exception as e:
        logger.exception(
            f"Unexpected error processing user {user_id}: {e}",
            extra={'user_id': user_id}
        )
        raise
```

### Context Managers for Resource Management
```python
import contextlib
from pathlib import Path

@contextlib.contextmanager
def safe_file_operation(file_path, mode='r'):
    """Context manager for safe file operations."""
    file_obj = None
    try:
        file_obj = open(file_path, mode)
        yield file_obj
    except FileNotFoundError:
        logger.error(f"File not found: {file_path}")
        raise
    except PermissionError:
        logger.error(f"Permission denied: {file_path}")
        raise
    except IOError as e:
        logger.error(f"I/O error with file {file_path}: {e}")
        raise
    finally:
        if file_obj:
            file_obj.close()

# Usage
try:
    with safe_file_operation('config.json') as f:
        data = json.load(f)
except (FileNotFoundError, PermissionError, IOError):
    # Handle errors appropriately
    data = create_default_config()
```

## Error Recovery Patterns

### Graceful Degradation
```python
def get_user_preferences(user_id, use_cache=True):
    """Get user preferences with graceful degradation."""
    try:
        # Try primary data source
        return fetch_from_database(user_id)
        
    except DatabaseError as e:
        logger.warning(f"Database error, trying cache: {e}")
        
        if use_cache:
            try:
                return fetch_from_cache(user_id)
            except CacheError:
                logger.warning("Cache also failed, using defaults")
        
        # Fall back to defaults
        return get_default_preferences()

def send_notification(user_id, message):
    """Send notification with multiple fallback methods."""
    methods = [
        ('email', send_email),
        ('sms', send_sms),
        ('push', send_push_notification)
    ]
    
    for method_name, method_func in methods:
        try:
            result = method_func(user_id, message)
            logger.info(f"Notification sent via {method_name}")
            return result
            
        except NotificationError as e:
            logger.warning(f"{method_name} notification failed: {e}")
            continue
    
    # All methods failed
    logger.error(f"All notification methods failed for user {user_id}")
    raise NotificationError("All notification methods failed")
```

## Best Practices

### ✅ DO:
- **Use specific exception types** that clearly indicate the error
- **Include contextual information** in error messages
- **Log errors with appropriate levels** (warning, error, critical)
- **Implement retry logic** for transient failures
- **Use context managers** for resource management
- **Create custom exceptions** for domain-specific errors
- **Handle errors at the appropriate level** in your application

### ❌ DON'T:
- **Use bare except clauses** - they catch everything, including system exits
- **Ignore exceptions silently** - always log or handle appropriately
- **Raise generic exceptions** when specific ones would be more helpful
- **Retry indefinitely** - always set retry limits
- **Log sensitive information** in error messages
- **Re-raise exceptions without context** - add meaningful information

**Remember: Good error handling makes your application more robust and easier to debug. Always think about what could go wrong and handle it gracefully.**